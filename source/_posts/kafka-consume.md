---
title: Kafka学习笔记 -- 读取数据
date: 2018-10-18 15:30:51
categories:
  - Kafka
tags:
  - Kafka
---

## KafkaConsumer

### 消费者和消费者群组
**消费者从属于消费者群组**。一个群组里的消费者**订阅的是同一个主题**，**每个消费者接收主题一部分分区的消息**

#### 消费者横向扩展

##### 1个消费者
1. 主题T1有4个分区，然后创建消费者C1，C1是消费者群组G1里唯一的消费者，C1订阅T1
2. **消费者C1将接收主题T1的全部4个分区的消息**

![consumer_topic_1.png](http://pg67n0yz6.bkt.clouddn.com/consumer_topic_1.png?imageView2/2/w/300)

<!-- more -->

##### 2个消费者
1. 如果群组G1新增一个消费者C2，那么每个消费者将**分别从两个分区接收消息**
2. 假设C1接收分区0和分区2的消息，C2接收分区1和分区3的消息

![consumer_topic_2.png](http://pg67n0yz6.bkt.clouddn.com/consumer_topic_2.png?imageView2/2/w/300)

##### 4个消费者
1. 如果群组G1有4个消费者，那么每个消费者可以分配到一个分区

![consumer_topic_3.png](http://pg67n0yz6.bkt.clouddn.com/consumer_topic_3.png?imageView2/2/w/300)

##### 5个消费者
1. 如果群组G1有5个消费者，**超过主题的分区数量**，那么有1个消费者就会被**闲置**，不会接收到任何消息

![consumer_topic_4.png](http://pg67n0yz6.bkt.clouddn.com/consumer_topic_4.png?imageView2/2/w/300)

##### 总结
1. 往群组里增加消费者是**横向伸缩消费能力**的主要方式
2. 消费者经常会做一些高延迟的操作，比如把数据写到数据库或HDFS，或者使用数据进行比较耗时的计算
3. 有必要**为主题创建大量的分区**，在负载增长时可以加入更多的消费者
    - 不要让**消费者的数量超过主题分区的数量**，多余的消费者只会被**闲置**

#### 消费者群组横向扩展
1. Kafka设计的主要目标之一，就是要让Kafka主题里的数据能够满足企业各种应用场景（**不同的消费者群组**）的需求
2. 在这些场景里，每个应用程序可以获取到**所有的消息**，而不只是其中的一部分
3. 只要保证每个应用程序有自己的消费者群组，就可以让它们获取到主题所有的消息
4. 不同于传统的消息系统，**横向伸缩Kafka消费者和消费者群组并不会对性能造成负面影响**

![consumer_topic_5.png](http://pg67n0yz6.bkt.clouddn.com/consumer_topic_5.png?imageView2/2/w/300)

### 消费者群组+分区再均衡

#### 分区再均衡
1. 分区再均衡：**分区的所有权从一个消费者转移到另一个消费者**
2. 分区再均衡非常重要，它为消费者群组带来了**高可用性**和**伸缩性**（可以放心地添加或移出消费者）
3. 在分区再均衡期间，**消费者无法读取消息**，造成整个群组一小段时间内不可用
4. 当分区被重新分配给另一个消费者时，消费者当前的读取状态会丢失，它有可能需要去刷新缓存，在它重新恢复状态之前会拖慢应用程序

#### 心跳
1. 消费者通过向被指派为**群组协调器**的Broker（**不同的群组可以有不同的协调器**）发送**心跳**来维持它们**和群组的从属关系**以及它们**对分区的所有权关系**
2. 只要消费者以**正常的时间间隔**发送心跳，就被认为是**活跃**的，说明它还在读取分区里的消息
3. 消费者发送心跳的时机
    - **轮询消息**（为了获取消息）
    - **提交偏移量**
4. 如果消费者停止发送心跳的时间足够长，会话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡
5. 如果一个消费者发生崩溃，并停止读取消息，群组协调器会等待几秒钟，确认它死亡了才会触发再均衡
    - 在这几秒的时间内，死掉的消费者不会读取分区里的消息
6. 在清理消费者时，消费者会**通知**协调器它将要离开群组，协调器会**立即**触发一次再均衡，尽量**降低处理停顿**

#### 分配分区
1. 当消费者要加入群组时，它会向**群组协调器**发送一个**JoinGroup的请求**，**第一个** 加入群组的消费者将成为**群主**
2. **群主** 从**协调器**那里获得**群组的成员列表**（列表中包含了**最近发送过心跳的消费者**，它们被认为是活跃的），**并负责给每个消费者分配分区**
    - 实现PartitionAssignor接口的类来决定哪些分区应该被分配给哪个消费者
3. 群主分配完毕后，把**分配情况列表**发送给**群组协调器**，**群组协调器再把这些信息发送给所有的消费者**
    - **每个消费者只能看到自己的分配信息，只有群主知道群组里所有消费者的分配信息**
4. 这个过程会在每次再均衡时重复发生

## 创建消费者

## 订阅主题

## 轮询

## 消费者的配置

## 提交和偏移量

## 再均衡监听器

## 从特定偏移量开始处理记录
<!-- indicate-the-source -->
